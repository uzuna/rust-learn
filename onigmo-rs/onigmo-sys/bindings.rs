/* automatically generated by rust-bindgen */

pub const ONIGMO_VERSION_MAJOR: u32 = 6;
pub const ONIGMO_VERSION_MINOR: u32 = 2;
pub const ONIGMO_VERSION_TEENY: u32 = 0;
pub const OnigCodePointMaskWidth: u32 = 3;
pub const OnigCodePointMask: u32 = 7;
pub const OnigSpecialIndexShift: u32 = 3;
pub const OnigSpecialIndexWidth: u32 = 10;
pub const ONIGENC_CASE_UPCASE: u32 = 8192;
pub const ONIGENC_CASE_DOWNCASE: u32 = 16384;
pub const ONIGENC_CASE_TITLECASE: u32 = 32768;
pub const ONIGENC_CASE_SPECIAL_OFFSET: u32 = 3;
pub const ONIGENC_CASE_UP_SPECIAL: u32 = 65536;
pub const ONIGENC_CASE_DOWN_SPECIAL: u32 = 131072;
pub const ONIGENC_CASE_MODIFIED: u32 = 262144;
pub const ONIGENC_CASE_FOLD: u32 = 524288;
pub const ONIGENC_CASE_FOLD_TURKISH_AZERI: u32 = 1048576;
pub const ONIGENC_CASE_FOLD_LITHUANIAN: u32 = 2097152;
pub const ONIGENC_CASE_ASCII_ONLY: u32 = 4194304;
pub const ONIGENC_CASE_IS_TITLECASE: u32 = 8388608;
pub const INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR: u32 = 1073741824;
pub const ONIGENC_CASE_FOLD_MIN: u32 = 1073741824;
pub const ONIGENC_MAX_COMP_CASE_FOLD_CODE_LEN: u32 = 3;
pub const ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM: u32 = 13;
pub const ONIGENC_CODE_TO_MBC_MAXLEN: u32 = 7;
pub const ONIGENC_MBC_CASE_FOLD_MAXLEN: u32 = 18;
pub const ONIGENC_CTYPE_NEWLINE: u32 = 0;
pub const ONIGENC_CTYPE_ALPHA: u32 = 1;
pub const ONIGENC_CTYPE_BLANK: u32 = 2;
pub const ONIGENC_CTYPE_CNTRL: u32 = 3;
pub const ONIGENC_CTYPE_DIGIT: u32 = 4;
pub const ONIGENC_CTYPE_GRAPH: u32 = 5;
pub const ONIGENC_CTYPE_LOWER: u32 = 6;
pub const ONIGENC_CTYPE_PRINT: u32 = 7;
pub const ONIGENC_CTYPE_PUNCT: u32 = 8;
pub const ONIGENC_CTYPE_SPACE: u32 = 9;
pub const ONIGENC_CTYPE_UPPER: u32 = 10;
pub const ONIGENC_CTYPE_XDIGIT: u32 = 11;
pub const ONIGENC_CTYPE_WORD: u32 = 12;
pub const ONIGENC_CTYPE_ALNUM: u32 = 13;
pub const ONIGENC_CTYPE_ASCII: u32 = 14;
pub const ONIGENC_MAX_STD_CTYPE: u32 = 14;
pub const ONIGENC_FLAG_NONE: u32 = 0;
pub const ONIGENC_FLAG_UNICODE: u32 = 1;
pub const ONIG_NREGION: u32 = 10;
pub const ONIG_MAX_CAPTURE_GROUP_NUM: u32 = 32767;
pub const ONIG_MAX_BACKREF_NUM: u32 = 1000;
pub const ONIG_MAX_REPEAT_NUM: u32 = 100000;
pub const ONIG_MAX_MULTI_BYTE_RANGES_NUM: u32 = 10000;
pub const ONIG_MAX_ERROR_MESSAGE_LEN: u32 = 90;
pub const ONIG_OPTION_NONE: u32 = 0;
pub const ONIG_OPTION_IGNORECASE: u32 = 1;
pub const ONIG_OPTION_EXTEND: u32 = 2;
pub const ONIG_OPTION_MULTILINE: u32 = 4;
pub const ONIG_OPTION_DOTALL: u32 = 4;
pub const ONIG_OPTION_SINGLELINE: u32 = 8;
pub const ONIG_OPTION_FIND_LONGEST: u32 = 16;
pub const ONIG_OPTION_FIND_NOT_EMPTY: u32 = 32;
pub const ONIG_OPTION_NEGATE_SINGLELINE: u32 = 64;
pub const ONIG_OPTION_DONT_CAPTURE_GROUP: u32 = 128;
pub const ONIG_OPTION_CAPTURE_GROUP: u32 = 256;
pub const ONIG_OPTION_NOTBOL: u32 = 512;
pub const ONIG_OPTION_NOTEOL: u32 = 1024;
pub const ONIG_OPTION_NOTBOS: u32 = 2048;
pub const ONIG_OPTION_NOTEOS: u32 = 4096;
pub const ONIG_OPTION_ASCII_RANGE: u32 = 8192;
pub const ONIG_OPTION_POSIX_BRACKET_ALL_RANGE: u32 = 16384;
pub const ONIG_OPTION_WORD_BOUND_ALL_RANGE: u32 = 32768;
pub const ONIG_OPTION_NEWLINE_CRLF: u32 = 65536;
pub const ONIG_OPTION_MAXBIT: u32 = 65536;
pub const ONIG_SYN_OP_VARIABLE_META_CHARACTERS: u32 = 1;
pub const ONIG_SYN_OP_DOT_ANYCHAR: u32 = 2;
pub const ONIG_SYN_OP_ASTERISK_ZERO_INF: u32 = 4;
pub const ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF: u32 = 8;
pub const ONIG_SYN_OP_PLUS_ONE_INF: u32 = 16;
pub const ONIG_SYN_OP_ESC_PLUS_ONE_INF: u32 = 32;
pub const ONIG_SYN_OP_QMARK_ZERO_ONE: u32 = 64;
pub const ONIG_SYN_OP_ESC_QMARK_ZERO_ONE: u32 = 128;
pub const ONIG_SYN_OP_BRACE_INTERVAL: u32 = 256;
pub const ONIG_SYN_OP_ESC_BRACE_INTERVAL: u32 = 512;
pub const ONIG_SYN_OP_VBAR_ALT: u32 = 1024;
pub const ONIG_SYN_OP_ESC_VBAR_ALT: u32 = 2048;
pub const ONIG_SYN_OP_LPAREN_SUBEXP: u32 = 4096;
pub const ONIG_SYN_OP_ESC_LPAREN_SUBEXP: u32 = 8192;
pub const ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR: u32 = 16384;
pub const ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR: u32 = 32768;
pub const ONIG_SYN_OP_DECIMAL_BACKREF: u32 = 65536;
pub const ONIG_SYN_OP_BRACKET_CC: u32 = 131072;
pub const ONIG_SYN_OP_ESC_W_WORD: u32 = 262144;
pub const ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END: u32 = 524288;
pub const ONIG_SYN_OP_ESC_B_WORD_BOUND: u32 = 1048576;
pub const ONIG_SYN_OP_ESC_S_WHITE_SPACE: u32 = 2097152;
pub const ONIG_SYN_OP_ESC_D_DIGIT: u32 = 4194304;
pub const ONIG_SYN_OP_LINE_ANCHOR: u32 = 8388608;
pub const ONIG_SYN_OP_POSIX_BRACKET: u32 = 16777216;
pub const ONIG_SYN_OP_QMARK_NON_GREEDY: u32 = 33554432;
pub const ONIG_SYN_OP_ESC_CONTROL_CHARS: u32 = 67108864;
pub const ONIG_SYN_OP_ESC_C_CONTROL: u32 = 134217728;
pub const ONIG_SYN_OP_ESC_OCTAL3: u32 = 268435456;
pub const ONIG_SYN_OP_ESC_X_HEX2: u32 = 536870912;
pub const ONIG_SYN_OP_ESC_X_BRACE_HEX8: u32 = 1073741824;
pub const ONIG_SYN_OP_ESC_O_BRACE_OCTAL: u32 = 2147483648;
pub const ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE: u32 = 1;
pub const ONIG_SYN_OP2_QMARK_GROUP_EFFECT: u32 = 2;
pub const ONIG_SYN_OP2_OPTION_PERL: u32 = 4;
pub const ONIG_SYN_OP2_OPTION_RUBY: u32 = 8;
pub const ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT: u32 = 16;
pub const ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL: u32 = 32;
pub const ONIG_SYN_OP2_CCLASS_SET_OP: u32 = 64;
pub const ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP: u32 = 128;
pub const ONIG_SYN_OP2_ESC_K_NAMED_BACKREF: u32 = 256;
pub const ONIG_SYN_OP2_ESC_G_SUBEXP_CALL: u32 = 512;
pub const ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY: u32 = 1024;
pub const ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL: u32 = 2048;
pub const ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META: u32 = 4096;
pub const ONIG_SYN_OP2_ESC_V_VTAB: u32 = 8192;
pub const ONIG_SYN_OP2_ESC_U_HEX4: u32 = 16384;
pub const ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR: u32 = 32768;
pub const ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY: u32 = 65536;
pub const ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT: u32 = 131072;
pub const ONIG_SYN_OP2_ESC_H_XDIGIT: u32 = 524288;
pub const ONIG_SYN_OP2_INEFFECTIVE_ESCAPE: u32 = 1048576;
pub const ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK: u32 = 2097152;
pub const ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER: u32 = 4194304;
pub const ONIG_SYN_OP2_ESC_V_VERTICAL_WHITESPACE: u32 = 8388608;
pub const ONIG_SYN_OP2_ESC_H_HORIZONTAL_WHITESPACE: u32 = 16777216;
pub const ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP: u32 = 33554432;
pub const ONIG_SYN_OP2_ESC_G_BRACE_BACKREF: u32 = 67108864;
pub const ONIG_SYN_OP2_QMARK_SUBEXP_CALL: u32 = 134217728;
pub const ONIG_SYN_OP2_QMARK_VBAR_BRANCH_RESET: u32 = 268435456;
pub const ONIG_SYN_OP2_QMARK_LPAREN_CONDITION: u32 = 536870912;
pub const ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP: u32 = 1073741824;
pub const ONIG_SYN_OP2_QMARK_TILDE_ABSENT: u32 = 2147483648;
pub const ONIG_SYN_CONTEXT_INDEP_ANCHORS: u32 = 2147483648;
pub const ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS: u32 = 1;
pub const ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS: u32 = 2;
pub const ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP: u32 = 4;
pub const ONIG_SYN_ALLOW_INVALID_INTERVAL: u32 = 8;
pub const ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV: u32 = 16;
pub const ONIG_SYN_STRICT_CHECK_BACKREF: u32 = 32;
pub const ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND: u32 = 64;
pub const ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP: u32 = 128;
pub const ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME: u32 = 256;
pub const ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY: u32 = 512;
pub const ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME_CALL: u32 = 1024;
pub const ONIG_SYN_USE_LEFT_MOST_NAMED_GROUP: u32 = 2048;
pub const ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC: u32 = 1048576;
pub const ONIG_SYN_BACKSLASH_ESCAPE_IN_CC: u32 = 2097152;
pub const ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC: u32 = 4194304;
pub const ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC: u32 = 8388608;
pub const ONIG_SYN_WARN_CC_OP_NOT_ESCAPED: u32 = 16777216;
pub const ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT: u32 = 33554432;
pub const ONIG_SYN_WARN_CC_DUP: u32 = 67108864;
pub const ONIG_META_CHAR_ESCAPE: u32 = 0;
pub const ONIG_META_CHAR_ANYCHAR: u32 = 1;
pub const ONIG_META_CHAR_ANYTIME: u32 = 2;
pub const ONIG_META_CHAR_ZERO_OR_ONE_TIME: u32 = 3;
pub const ONIG_META_CHAR_ONE_OR_MORE_TIME: u32 = 4;
pub const ONIG_META_CHAR_ANYCHAR_ANYTIME: u32 = 5;
pub const ONIG_INEFFECTIVE_META_CHAR: u32 = 0;
pub const ONIG_NORMAL: u32 = 0;
pub const ONIG_MISMATCH: i32 = -1;
pub const ONIG_NO_SUPPORT_CONFIG: i32 = -2;
pub const ONIGERR_MEMORY: i32 = -5;
pub const ONIGERR_TYPE_BUG: i32 = -6;
pub const ONIGERR_PARSER_BUG: i32 = -11;
pub const ONIGERR_STACK_BUG: i32 = -12;
pub const ONIGERR_UNDEFINED_BYTECODE: i32 = -13;
pub const ONIGERR_UNEXPECTED_BYTECODE: i32 = -14;
pub const ONIGERR_MATCH_STACK_LIMIT_OVER: i32 = -15;
pub const ONIGERR_PARSE_DEPTH_LIMIT_OVER: i32 = -16;
pub const ONIGERR_DEFAULT_ENCODING_IS_NOT_SET: i32 = -21;
pub const ONIGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR: i32 = -22;
pub const ONIGERR_INVALID_ARGUMENT: i32 = -30;
pub const ONIGERR_END_PATTERN_AT_LEFT_BRACE: i32 = -100;
pub const ONIGERR_END_PATTERN_AT_LEFT_BRACKET: i32 = -101;
pub const ONIGERR_EMPTY_CHAR_CLASS: i32 = -102;
pub const ONIGERR_PREMATURE_END_OF_CHAR_CLASS: i32 = -103;
pub const ONIGERR_END_PATTERN_AT_ESCAPE: i32 = -104;
pub const ONIGERR_END_PATTERN_AT_META: i32 = -105;
pub const ONIGERR_END_PATTERN_AT_CONTROL: i32 = -106;
pub const ONIGERR_META_CODE_SYNTAX: i32 = -108;
pub const ONIGERR_CONTROL_CODE_SYNTAX: i32 = -109;
pub const ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE: i32 = -110;
pub const ONIGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE: i32 = -111;
pub const ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS: i32 = -112;
pub const ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED: i32 = -113;
pub const ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID: i32 = -114;
pub const ONIGERR_NESTED_REPEAT_OPERATOR: i32 = -115;
pub const ONIGERR_UNMATCHED_CLOSE_PARENTHESIS: i32 = -116;
pub const ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS: i32 = -117;
pub const ONIGERR_END_PATTERN_IN_GROUP: i32 = -118;
pub const ONIGERR_UNDEFINED_GROUP_OPTION: i32 = -119;
pub const ONIGERR_INVALID_POSIX_BRACKET_TYPE: i32 = -121;
pub const ONIGERR_INVALID_LOOK_BEHIND_PATTERN: i32 = -122;
pub const ONIGERR_INVALID_REPEAT_RANGE_PATTERN: i32 = -123;
pub const ONIGERR_INVALID_CONDITION_PATTERN: i32 = -124;
pub const ONIGERR_TOO_BIG_NUMBER: i32 = -200;
pub const ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE: i32 = -201;
pub const ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE: i32 = -202;
pub const ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS: i32 = -203;
pub const ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE: i32 = -204;
pub const ONIGERR_TOO_MANY_MULTI_BYTE_RANGES: i32 = -205;
pub const ONIGERR_TOO_SHORT_MULTI_BYTE_STRING: i32 = -206;
pub const ONIGERR_TOO_BIG_BACKREF_NUMBER: i32 = -207;
pub const ONIGERR_INVALID_BACKREF: i32 = -208;
pub const ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED: i32 = -209;
pub const ONIGERR_TOO_MANY_CAPTURE_GROUPS: i32 = -210;
pub const ONIGERR_TOO_SHORT_DIGITS: i32 = -211;
pub const ONIGERR_TOO_LONG_WIDE_CHAR_VALUE: i32 = -212;
pub const ONIGERR_EMPTY_GROUP_NAME: i32 = -214;
pub const ONIGERR_INVALID_GROUP_NAME: i32 = -215;
pub const ONIGERR_INVALID_CHAR_IN_GROUP_NAME: i32 = -216;
pub const ONIGERR_UNDEFINED_NAME_REFERENCE: i32 = -217;
pub const ONIGERR_UNDEFINED_GROUP_REFERENCE: i32 = -218;
pub const ONIGERR_MULTIPLEX_DEFINED_NAME: i32 = -219;
pub const ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL: i32 = -220;
pub const ONIGERR_NEVER_ENDING_RECURSION: i32 = -221;
pub const ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY: i32 = -222;
pub const ONIGERR_INVALID_CHAR_PROPERTY_NAME: i32 = -223;
pub const ONIGERR_INVALID_CODE_POINT_VALUE: i32 = -400;
pub const ONIGERR_INVALID_WIDE_CHAR_VALUE: i32 = -400;
pub const ONIGERR_TOO_BIG_WIDE_CHAR_VALUE: i32 = -401;
pub const ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION: i32 = -402;
pub const ONIGERR_INVALID_COMBINATION_OF_OPTIONS: i32 = -403;
pub const ONIG_MAX_CAPTURE_HISTORY_GROUP: u32 = 31;
pub const ONIG_TRAVERSE_CALLBACK_AT_FIRST: u32 = 1;
pub const ONIG_TRAVERSE_CALLBACK_AT_LAST: u32 = 2;
pub const ONIG_TRAVERSE_CALLBACK_AT_BOTH: u32 = 3;
pub const ONIG_REGION_NOTPOS: i32 = -1;
pub const ONIG_CHAR_TABLE_SIZE: u32 = 256;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type OnigUChar = ::std::os::raw::c_uchar;
pub type OnigCodePoint = ::std::os::raw::c_uint;
pub type OnigCtype = ::std::os::raw::c_uint;
pub type OnigDistance = usize;
pub type OnigPosition = isize;
pub type OnigCaseFoldType = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}OnigDefaultCaseFoldFlag"]
    pub static mut OnigDefaultCaseFoldFlag: OnigCaseFoldType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigCaseFoldCodeItem {
    pub byte_len: ::std::os::raw::c_int,
    pub code_len: ::std::os::raw::c_int,
    pub code: [OnigCodePoint; 3usize],
}
#[test]
fn bindgen_test_layout_OnigCaseFoldCodeItem() {
    assert_eq!(
        ::std::mem::size_of::<OnigCaseFoldCodeItem>(),
        20usize,
        concat!("Size of: ", stringify!(OnigCaseFoldCodeItem))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigCaseFoldCodeItem>(),
        4usize,
        concat!("Alignment of ", stringify!(OnigCaseFoldCodeItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCaseFoldCodeItem>())).byte_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCaseFoldCodeItem),
            "::",
            stringify!(byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCaseFoldCodeItem>())).code_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCaseFoldCodeItem),
            "::",
            stringify!(code_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCaseFoldCodeItem>())).code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCaseFoldCodeItem),
            "::",
            stringify!(code)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigMetaCharTableType {
    pub esc: OnigCodePoint,
    pub anychar: OnigCodePoint,
    pub anytime: OnigCodePoint,
    pub zero_or_one_time: OnigCodePoint,
    pub one_or_more_time: OnigCodePoint,
    pub anychar_anytime: OnigCodePoint,
}
#[test]
fn bindgen_test_layout_OnigMetaCharTableType() {
    assert_eq!(
        ::std::mem::size_of::<OnigMetaCharTableType>(),
        24usize,
        concat!("Size of: ", stringify!(OnigMetaCharTableType))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigMetaCharTableType>(),
        4usize,
        concat!("Alignment of ", stringify!(OnigMetaCharTableType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigMetaCharTableType>())).esc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(esc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigMetaCharTableType>())).anychar as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(anychar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigMetaCharTableType>())).anytime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(anytime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigMetaCharTableType>())).zero_or_one_time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(zero_or_one_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigMetaCharTableType>())).one_or_more_time as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(one_or_more_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigMetaCharTableType>())).anychar_anytime as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigMetaCharTableType),
            "::",
            stringify!(anychar_anytime)
        )
    );
}
pub type OnigApplyAllCaseFoldFunc = ::std::option::Option<
    unsafe extern "C" fn(
        from: OnigCodePoint,
        to: *mut OnigCodePoint,
        to_len: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigEncodingTypeST {
    pub precise_mbc_enc_len: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            e: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *const ::std::os::raw::c_char,
    pub max_enc_len: ::std::os::raw::c_int,
    pub min_enc_len: ::std::os::raw::c_int,
    pub is_mbc_newline: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_to_code: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> OnigCodePoint,
    >,
    pub code_to_mbclen: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub code_to_mbc: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            buf: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub mbc_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub apply_all_case_fold: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            f: OnigApplyAllCaseFoldFunc,
            arg: *mut ::std::os::raw::c_void,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_case_fold_codes_by_str: ::std::option::Option<
        unsafe extern "C" fn(
            flag: OnigCaseFoldType,
            p: *const OnigUChar,
            end: *const OnigUChar,
            acs: *mut OnigCaseFoldCodeItem,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub property_name_to_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            enc: *const OnigEncodingTypeST,
            p: *const OnigUChar,
            end: *const OnigUChar,
        ) -> ::std::os::raw::c_int,
    >,
    pub is_code_ctype: ::std::option::Option<
        unsafe extern "C" fn(
            code: OnigCodePoint,
            ctype: OnigCtype,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_ctype_code_range: ::std::option::Option<
        unsafe extern "C" fn(
            ctype: OnigCtype,
            sb_out: *mut OnigCodePoint,
            ranges: *mut *const OnigCodePoint,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub left_adjust_char_head: ::std::option::Option<
        unsafe extern "C" fn(
            start: *const OnigUChar,
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> *mut OnigUChar,
    >,
    pub is_allowed_reverse_match: ::std::option::Option<
        unsafe extern "C" fn(
            p: *const OnigUChar,
            end: *const OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub case_map: ::std::option::Option<
        unsafe extern "C" fn(
            flagP: *mut OnigCaseFoldType,
            pp: *mut *const OnigUChar,
            end: *const OnigUChar,
            to: *mut OnigUChar,
            to_end: *mut OnigUChar,
            enc: *const OnigEncodingTypeST,
        ) -> ::std::os::raw::c_int,
    >,
    pub ruby_encoding_index: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_OnigEncodingTypeST() {
    assert_eq!(
        ::std::mem::size_of::<OnigEncodingTypeST>(),
        136usize,
        concat!("Size of: ", stringify!(OnigEncodingTypeST))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigEncodingTypeST>(),
        8usize,
        concat!("Alignment of ", stringify!(OnigEncodingTypeST))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).precise_mbc_enc_len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(precise_mbc_enc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).max_enc_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(max_enc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).min_enc_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(min_enc_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).is_mbc_newline as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(is_mbc_newline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).mbc_to_code as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(mbc_to_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).code_to_mbclen as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(code_to_mbclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).code_to_mbc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(code_to_mbc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).mbc_case_fold as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(mbc_case_fold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).apply_all_case_fold as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(apply_all_case_fold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).get_case_fold_codes_by_str as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(get_case_fold_codes_by_str)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).property_name_to_ctype as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(property_name_to_ctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).is_code_ctype as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(is_code_ctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).get_ctype_code_range as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(get_ctype_code_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).left_adjust_char_head as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(left_adjust_char_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).is_allowed_reverse_match as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(is_allowed_reverse_match)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).case_map as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(case_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnigEncodingTypeST>())).ruby_encoding_index as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(ruby_encoding_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigEncodingTypeST>())).flags as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigEncodingTypeST),
            "::",
            stringify!(flags)
        )
    );
}
pub type OnigEncodingType = OnigEncodingTypeST;
pub type OnigEncoding = *const OnigEncodingType;
extern "C" {
    #[link_name = "\u{1}OnigEncodingASCII"]
    pub static OnigEncodingASCII: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_1"]
    pub static OnigEncodingISO_8859_1: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_2"]
    pub static OnigEncodingISO_8859_2: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_3"]
    pub static OnigEncodingISO_8859_3: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_4"]
    pub static OnigEncodingISO_8859_4: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_5"]
    pub static OnigEncodingISO_8859_5: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_6"]
    pub static OnigEncodingISO_8859_6: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_7"]
    pub static OnigEncodingISO_8859_7: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_8"]
    pub static OnigEncodingISO_8859_8: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_9"]
    pub static OnigEncodingISO_8859_9: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_10"]
    pub static OnigEncodingISO_8859_10: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_11"]
    pub static OnigEncodingISO_8859_11: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_13"]
    pub static OnigEncodingISO_8859_13: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_14"]
    pub static OnigEncodingISO_8859_14: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_15"]
    pub static OnigEncodingISO_8859_15: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingISO_8859_16"]
    pub static OnigEncodingISO_8859_16: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingUTF_8"]
    pub static OnigEncodingUTF_8: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingUTF_16BE"]
    pub static OnigEncodingUTF_16BE: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingUTF_16LE"]
    pub static OnigEncodingUTF_16LE: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingUTF_32BE"]
    pub static OnigEncodingUTF_32BE: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingUTF_32LE"]
    pub static OnigEncodingUTF_32LE: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingEUC_JP"]
    pub static OnigEncodingEUC_JP: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingEUC_TW"]
    pub static OnigEncodingEUC_TW: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingEUC_KR"]
    pub static OnigEncodingEUC_KR: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingEUC_CN"]
    pub static OnigEncodingEUC_CN: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingShift_JIS"]
    pub static OnigEncodingShift_JIS: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_31J"]
    pub static OnigEncodingWindows_31J: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingKOI8_R"]
    pub static OnigEncodingKOI8_R: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingKOI8_U"]
    pub static OnigEncodingKOI8_U: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1250"]
    pub static OnigEncodingWindows_1250: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1251"]
    pub static OnigEncodingWindows_1251: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1252"]
    pub static OnigEncodingWindows_1252: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1253"]
    pub static OnigEncodingWindows_1253: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1254"]
    pub static OnigEncodingWindows_1254: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingWindows_1257"]
    pub static OnigEncodingWindows_1257: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingBIG5"]
    pub static OnigEncodingBIG5: OnigEncodingType;
}
extern "C" {
    #[link_name = "\u{1}OnigEncodingGB18030"]
    pub static OnigEncodingGB18030: OnigEncodingType;
}
extern "C" {
    pub fn onigenc_ascii_only_case_map(
        flagP: *mut OnigCaseFoldType,
        pp: *mut *const OnigUChar,
        end: *const OnigUChar,
        to: *mut OnigUChar,
        to_end: *mut OnigUChar,
        enc: *const OnigEncodingTypeST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_mbclen_approximate(
        p: *const OnigUChar,
        e: *const OnigUChar,
        enc: *const OnigEncodingTypeST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_step_back(
        enc: OnigEncoding,
        start: *const OnigUChar,
        s: *const OnigUChar,
        end: *const OnigUChar,
        n: ::std::os::raw::c_int,
    ) -> *mut OnigUChar;
}
extern "C" {
    pub fn onigenc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_set_default_encoding(enc: OnigEncoding) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_get_default_encoding() -> OnigEncoding;
}
extern "C" {
    pub fn onigenc_get_right_adjust_char_head_with_prev(
        enc: OnigEncoding,
        start: *const OnigUChar,
        s: *const OnigUChar,
        end: *const OnigUChar,
        prev: *mut *const OnigUChar,
    ) -> *mut OnigUChar;
}
extern "C" {
    pub fn onigenc_get_prev_char_head(
        enc: OnigEncoding,
        start: *const OnigUChar,
        s: *const OnigUChar,
        end: *const OnigUChar,
    ) -> *mut OnigUChar;
}
extern "C" {
    pub fn onigenc_get_left_adjust_char_head(
        enc: OnigEncoding,
        start: *const OnigUChar,
        s: *const OnigUChar,
        end: *const OnigUChar,
    ) -> *mut OnigUChar;
}
extern "C" {
    pub fn onigenc_get_right_adjust_char_head(
        enc: OnigEncoding,
        start: *const OnigUChar,
        s: *const OnigUChar,
        end: *const OnigUChar,
    ) -> *mut OnigUChar;
}
extern "C" {
    pub fn onigenc_strlen(
        enc: OnigEncoding,
        p: *const OnigUChar,
        end: *const OnigUChar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_strlen_null(enc: OnigEncoding, p: *const OnigUChar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onigenc_str_bytelen_null(
        enc: OnigEncoding,
        p: *const OnigUChar,
    ) -> ::std::os::raw::c_int;
}
pub type OnigOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigSyntaxType {
    pub op: ::std::os::raw::c_uint,
    pub op2: ::std::os::raw::c_uint,
    pub behavior: ::std::os::raw::c_uint,
    pub options: OnigOptionType,
    pub meta_char_table: OnigMetaCharTableType,
}
#[test]
fn bindgen_test_layout_OnigSyntaxType() {
    assert_eq!(
        ::std::mem::size_of::<OnigSyntaxType>(),
        40usize,
        concat!("Size of: ", stringify!(OnigSyntaxType))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigSyntaxType>(),
        4usize,
        concat!("Alignment of ", stringify!(OnigSyntaxType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigSyntaxType>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigSyntaxType),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigSyntaxType>())).op2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigSyntaxType),
            "::",
            stringify!(op2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigSyntaxType>())).behavior as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigSyntaxType),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigSyntaxType>())).options as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigSyntaxType),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigSyntaxType>())).meta_char_table as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigSyntaxType),
            "::",
            stringify!(meta_char_table)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxASIS"]
    pub static OnigSyntaxASIS: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPosixBasic"]
    pub static OnigSyntaxPosixBasic: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPosixExtended"]
    pub static OnigSyntaxPosixExtended: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxEmacs"]
    pub static OnigSyntaxEmacs: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxGrep"]
    pub static OnigSyntaxGrep: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxGnuRegex"]
    pub static OnigSyntaxGnuRegex: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxJava"]
    pub static OnigSyntaxJava: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPerl58"]
    pub static OnigSyntaxPerl58: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPerl58_NG"]
    pub static OnigSyntaxPerl58_NG: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPerl"]
    pub static OnigSyntaxPerl: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxRuby"]
    pub static OnigSyntaxRuby: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigSyntaxPython"]
    pub static OnigSyntaxPython: OnigSyntaxType;
}
extern "C" {
    #[link_name = "\u{1}OnigDefaultSyntax"]
    pub static mut OnigDefaultSyntax: *const OnigSyntaxType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_registers {
    pub allocated: ::std::os::raw::c_int,
    pub num_regs: ::std::os::raw::c_int,
    pub beg: *mut OnigPosition,
    pub end: *mut OnigPosition,
}
#[test]
fn bindgen_test_layout_re_registers() {
    assert_eq!(
        ::std::mem::size_of::<re_registers>(),
        24usize,
        concat!("Size of: ", stringify!(re_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<re_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(re_registers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).allocated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).num_regs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(num_regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).beg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(beg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_registers>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(re_registers),
            "::",
            stringify!(end)
        )
    );
}
pub type OnigRegion = re_registers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigErrorInfo {
    pub enc: OnigEncoding,
    pub par: *mut OnigUChar,
    pub par_end: *mut OnigUChar,
}
#[test]
fn bindgen_test_layout_OnigErrorInfo() {
    assert_eq!(
        ::std::mem::size_of::<OnigErrorInfo>(),
        24usize,
        concat!("Size of: ", stringify!(OnigErrorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OnigErrorInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigErrorInfo>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigErrorInfo),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigErrorInfo>())).par as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigErrorInfo),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigErrorInfo>())).par_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigErrorInfo),
            "::",
            stringify!(par_end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigRepeatRange {
    pub lower: ::std::os::raw::c_int,
    pub upper: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OnigRepeatRange() {
    assert_eq!(
        ::std::mem::size_of::<OnigRepeatRange>(),
        8usize,
        concat!("Size of: ", stringify!(OnigRepeatRange))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigRepeatRange>(),
        4usize,
        concat!("Alignment of ", stringify!(OnigRepeatRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigRepeatRange>())).lower as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigRepeatRange),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigRepeatRange>())).upper as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigRepeatRange),
            "::",
            stringify!(upper)
        )
    );
}
pub type OnigWarnFunc =
    ::std::option::Option<unsafe extern "C" fn(s: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn onig_null_warn(s: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct re_pattern_buffer {
    pub p: *mut ::std::os::raw::c_uchar,
    pub used: ::std::os::raw::c_uint,
    pub alloc: ::std::os::raw::c_uint,
    pub num_mem: ::std::os::raw::c_int,
    pub num_repeat: ::std::os::raw::c_int,
    pub num_null_check: ::std::os::raw::c_int,
    pub num_comb_exp_check: ::std::os::raw::c_int,
    pub num_call: ::std::os::raw::c_int,
    pub capture_history: ::std::os::raw::c_uint,
    pub bt_mem_start: ::std::os::raw::c_uint,
    pub bt_mem_end: ::std::os::raw::c_uint,
    pub stack_pop_level: ::std::os::raw::c_int,
    pub repeat_range_alloc: ::std::os::raw::c_int,
    pub options: OnigOptionType,
    pub repeat_range: *mut OnigRepeatRange,
    pub enc: OnigEncoding,
    pub syntax: *const OnigSyntaxType,
    pub name_table: *mut ::std::os::raw::c_void,
    pub case_fold_flag: OnigCaseFoldType,
    pub optimize: ::std::os::raw::c_int,
    pub threshold_len: ::std::os::raw::c_int,
    pub anchor: ::std::os::raw::c_int,
    pub anchor_dmin: OnigDistance,
    pub anchor_dmax: OnigDistance,
    pub sub_anchor: ::std::os::raw::c_int,
    pub exact: *mut ::std::os::raw::c_uchar,
    pub exact_end: *mut ::std::os::raw::c_uchar,
    pub map: [::std::os::raw::c_uchar; 256usize],
    pub reserved1: *mut ::std::os::raw::c_int,
    pub reserved2: *mut ::std::os::raw::c_int,
    pub dmin: OnigDistance,
    pub dmax: OnigDistance,
    pub chain: *mut re_pattern_buffer,
}
#[test]
fn bindgen_test_layout_re_pattern_buffer() {
    assert_eq!(
        ::std::mem::size_of::<re_pattern_buffer>(),
        448usize,
        concat!("Size of: ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<re_pattern_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(re_pattern_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).used as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).alloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).num_mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(num_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).num_repeat as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(num_repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).num_null_check as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(num_null_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).num_comb_exp_check as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(num_comb_exp_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).num_call as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(num_call)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).capture_history as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(capture_history)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).bt_mem_start as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(bt_mem_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).bt_mem_end as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(bt_mem_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).stack_pop_level as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(stack_pop_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).repeat_range_alloc as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(repeat_range_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).options as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).repeat_range as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(repeat_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).enc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).syntax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).name_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(name_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<re_pattern_buffer>())).case_fold_flag as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(case_fold_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).optimize as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(optimize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).threshold_len as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(threshold_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).anchor as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).anchor_dmin as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(anchor_dmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).anchor_dmax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(anchor_dmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).sub_anchor as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(sub_anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).exact as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(exact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).exact_end as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(exact_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).map as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).reserved1 as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).reserved2 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).dmin as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(dmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).dmax as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(dmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<re_pattern_buffer>())).chain as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(re_pattern_buffer),
            "::",
            stringify!(chain)
        )
    );
}
pub type OnigRegexType = re_pattern_buffer;
pub type OnigRegex = *mut OnigRegexType;
pub type regex_t = OnigRegexType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnigCompileInfo {
    pub num_of_elements: ::std::os::raw::c_int,
    pub pattern_enc: OnigEncoding,
    pub target_enc: OnigEncoding,
    pub syntax: *const OnigSyntaxType,
    pub option: OnigOptionType,
    pub case_fold_flag: OnigCaseFoldType,
}
#[test]
fn bindgen_test_layout_OnigCompileInfo() {
    assert_eq!(
        ::std::mem::size_of::<OnigCompileInfo>(),
        40usize,
        concat!("Size of: ", stringify!(OnigCompileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<OnigCompileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(OnigCompileInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).num_of_elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(num_of_elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).pattern_enc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(pattern_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).target_enc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(target_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).syntax as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(syntax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).option as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnigCompileInfo>())).case_fold_flag as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OnigCompileInfo),
            "::",
            stringify!(case_fold_flag)
        )
    );
}
extern "C" {
    pub fn onig_initialize(
        encodings: *mut OnigEncoding,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_error_code_to_str(
        s: *mut OnigUChar,
        err_code: OnigPosition,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_set_warn_func(f: OnigWarnFunc);
}
extern "C" {
    pub fn onig_set_verb_warn_func(f: OnigWarnFunc);
}
extern "C" {
    pub fn onig_new(
        arg1: *mut OnigRegex,
        pattern: *const OnigUChar,
        pattern_end: *const OnigUChar,
        option: OnigOptionType,
        enc: OnigEncoding,
        syntax: *const OnigSyntaxType,
        einfo: *mut OnigErrorInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_reg_init(
        reg: OnigRegex,
        option: OnigOptionType,
        case_fold_flag: OnigCaseFoldType,
        enc: OnigEncoding,
        syntax: *const OnigSyntaxType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_new_without_alloc(
        arg1: OnigRegex,
        pattern: *const OnigUChar,
        pattern_end: *const OnigUChar,
        option: OnigOptionType,
        enc: OnigEncoding,
        syntax: *const OnigSyntaxType,
        einfo: *mut OnigErrorInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_new_deluxe(
        reg: *mut OnigRegex,
        pattern: *const OnigUChar,
        pattern_end: *const OnigUChar,
        ci: *mut OnigCompileInfo,
        einfo: *mut OnigErrorInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_free(arg1: OnigRegex);
}
extern "C" {
    pub fn onig_free_body(arg1: OnigRegex);
}
extern "C" {
    pub fn onig_scan(
        reg: OnigRegex,
        str: *const OnigUChar,
        end: *const OnigUChar,
        region: *mut OnigRegion,
        option: OnigOptionType,
        scan_callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: OnigPosition,
                arg2: OnigPosition,
                arg3: *mut OnigRegion,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        callback_arg: *mut ::std::os::raw::c_void,
    ) -> OnigPosition;
}
extern "C" {
    pub fn onig_search(
        arg1: OnigRegex,
        str: *const OnigUChar,
        end: *const OnigUChar,
        start: *const OnigUChar,
        range: *const OnigUChar,
        region: *mut OnigRegion,
        option: OnigOptionType,
    ) -> OnigPosition;
}
extern "C" {
    pub fn onig_search_gpos(
        arg1: OnigRegex,
        str: *const OnigUChar,
        end: *const OnigUChar,
        global_pos: *const OnigUChar,
        start: *const OnigUChar,
        range: *const OnigUChar,
        region: *mut OnigRegion,
        option: OnigOptionType,
    ) -> OnigPosition;
}
extern "C" {
    pub fn onig_match(
        arg1: OnigRegex,
        str: *const OnigUChar,
        end: *const OnigUChar,
        at: *const OnigUChar,
        region: *mut OnigRegion,
        option: OnigOptionType,
    ) -> OnigPosition;
}
extern "C" {
    pub fn onig_region_new() -> *mut OnigRegion;
}
extern "C" {
    pub fn onig_region_init(region: *mut OnigRegion);
}
extern "C" {
    pub fn onig_region_free(region: *mut OnigRegion, free_self: ::std::os::raw::c_int);
}
extern "C" {
    pub fn onig_region_copy(to: *mut OnigRegion, from: *const OnigRegion);
}
extern "C" {
    pub fn onig_region_clear(region: *mut OnigRegion);
}
extern "C" {
    pub fn onig_region_resize(
        region: *mut OnigRegion,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_region_set(
        region: *mut OnigRegion,
        at: ::std::os::raw::c_int,
        beg: ::std::os::raw::c_int,
        end: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_name_to_group_numbers(
        reg: OnigRegex,
        name: *const OnigUChar,
        name_end: *const OnigUChar,
        nums: *mut *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_name_to_backref_number(
        reg: OnigRegex,
        name: *const OnigUChar,
        name_end: *const OnigUChar,
        region: *const OnigRegion,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_foreach_name(
        reg: OnigRegex,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const OnigUChar,
                arg2: *const OnigUChar,
                arg3: ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int,
                arg5: OnigRegex,
                arg6: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_number_of_names(reg: *const OnigRegexType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_number_of_captures(reg: *const OnigRegexType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_number_of_capture_histories(reg: *const OnigRegexType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_capture_tree_traverse(
        region: *mut OnigRegion,
        at: ::std::os::raw::c_int,
        callback_func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: OnigPosition,
                arg3: OnigPosition,
                arg4: ::std::os::raw::c_int,
                arg5: ::std::os::raw::c_int,
                arg6: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_noname_group_capture_is_active(reg: *const OnigRegexType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_get_encoding(reg: *const OnigRegexType) -> OnigEncoding;
}
extern "C" {
    pub fn onig_get_options(reg: *const OnigRegexType) -> OnigOptionType;
}
extern "C" {
    pub fn onig_get_case_fold_flag(reg: *const OnigRegexType) -> OnigCaseFoldType;
}
extern "C" {
    pub fn onig_get_syntax(reg: *const OnigRegexType) -> *const OnigSyntaxType;
}
extern "C" {
    pub fn onig_set_default_syntax(syntax: *const OnigSyntaxType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_copy_syntax(to: *mut OnigSyntaxType, from: *const OnigSyntaxType);
}
extern "C" {
    pub fn onig_get_syntax_op(syntax: *const OnigSyntaxType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn onig_get_syntax_op2(syntax: *const OnigSyntaxType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn onig_get_syntax_behavior(syntax: *const OnigSyntaxType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn onig_get_syntax_options(syntax: *const OnigSyntaxType) -> OnigOptionType;
}
extern "C" {
    pub fn onig_set_syntax_op(syntax: *mut OnigSyntaxType, op: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn onig_set_syntax_op2(syntax: *mut OnigSyntaxType, op2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn onig_set_syntax_behavior(syntax: *mut OnigSyntaxType, behavior: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn onig_set_syntax_options(syntax: *mut OnigSyntaxType, options: OnigOptionType);
}
extern "C" {
    pub fn onig_set_meta_char(
        syntax: *mut OnigSyntaxType,
        what: ::std::os::raw::c_uint,
        code: OnigCodePoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_copy_encoding(to: *mut OnigEncodingType, from: OnigEncoding);
}
extern "C" {
    pub fn onig_get_default_case_fold_flag() -> OnigCaseFoldType;
}
extern "C" {
    pub fn onig_set_default_case_fold_flag(
        case_fold_flag: OnigCaseFoldType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_get_match_stack_limit_size() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn onig_set_match_stack_limit_size(size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_get_parse_depth_limit() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn onig_set_parse_depth_limit(depth: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_end() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onig_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn onig_copyright() -> *const ::std::os::raw::c_char;
}
